# Part 13: File Handling

## Chapter 1: Introduction to File I/O

### 1.1 Understanding File Handling Concepts

File handling is one of the most important aspects of programming, allowing your programs to interact with persistent data that remains available even after the program terminates. In this subchapter, we'll explore the fundamental concepts of file handling in C, which provides a powerful and flexible system for working with files of different types.

File handling in C allows your programs to read from and write to external files on your computer's storage system. This capability is essential for almost any real-world application, from simple configuration files to complex databases. Without file handling, your programs would be limited to working with temporary data that disappears once the program ends.

The C standard library provides a comprehensive set of functions for file operations through the `<stdio.h>` header. These functions allow you to create, open, read, write, and close files, as well as navigate within files. Understanding these functions and how they work together is crucial for effective file handling in C.

When working with files in C, you'll often use a file pointer, which is a variable of type `FILE*`. This pointer acts as a connection between your program and the physical file on disk. File pointers store information about the file being accessed, including the current position within the file and the mode in which the file was opened.

Before we dive into coding examples, it's important to understand the different file modes in C. Files can be opened in text mode or binary mode, and for various operations such as reading, writing, or both. The mode you choose affects how data is processed when reading from or writing to the file, and selecting the right mode is crucial for successful file operations.

#### Example 1: Opening and closing a file

```c
#include <stdio.h>

int main() {
    FILE *filePointer;

    // Opening a file in write mode
    filePointer = fopen("example.txt", "w");

    // Check if file was opened successfully
    if (filePointer == NULL) {
        printf("Failed to open the file.\n");
        return 1;
    }

    printf("File opened successfully.\n");

    // Closing the file
    fclose(filePointer);

    printf("File closed successfully.\n");

    return 0;
}
```

#### Example 2: Writing to a text file

```c
#include <stdio.h>

int main() {
    FILE *filePointer;

    // Open file in write mode
    filePointer = fopen("hello.txt", "w");

    if (filePointer == NULL) {
        printf("Failed to open the file.\n");
        return 1;
    }

    // Write text to file
    fprintf(filePointer, "Hello, File Handling in C!\n");
    fprintf(filePointer, "This is a simple example of writing to a file.\n");

    // Close the file
    fclose(filePointer);

    printf("Data written to the file successfully.\n");

    return 0;
}
```

#### Example 3: Reading from a text file

```c
#include <stdio.h>

int main() {
    FILE *filePointer;
    char buffer[100];

    // Open file in read mode
    filePointer = fopen("hello.txt", "r");

    if (filePointer == NULL) {
        printf("Failed to open the file.\n");
        return 1;
    }

    printf("File contents:\n");

    // Read and display file contents line by line
    while (fgets(buffer, sizeof(buffer), filePointer) != NULL) {
        printf("%s", buffer);
    }

    // Close the file
    fclose(filePointer);

    return 0;
}
```

#### Example 4: Appending to a text file

```c
#include <stdio.h>

int main() {
    FILE *filePointer;

    // Open file in append mode
    filePointer = fopen("hello.txt", "a");

    if (filePointer == NULL) {
        printf("Failed to open the file.\n");
        return 1;
    }

    // Append text to the file
    fprintf(filePointer, "This line is appended to the file.\n");
    fprintf(filePointer, "Appending allows adding content without overwriting.\n");

    // Close the file
    fclose(filePointer);

    printf("Data appended to the file successfully.\n");

    return 0;
}
```

#### Example 5: Character-by-character file reading

```c
#include <stdio.h>

int main() {
    FILE *filePointer;
    char ch;

    // Open file in read mode
    filePointer = fopen("hello.txt", "r");

    if (filePointer == NULL) {
        printf("Failed to open the file.\n");
        return 1;
    }

    printf("Reading file character by character:\n");

    // Read file character by character
    while ((ch = fgetc(filePointer)) != EOF) {
        putchar(ch);
    }

    // Close the file
    fclose(filePointer);

    return 0;
}
```

#### Exercise 1

Write a program that creates a new text file named "student.txt" and writes your name, age, and grade to it. Then read the file and display its contents.

#### Exercise 2

Create a program that asks the user for their name, email, and phone number, and then saves this information to a file named "contacts.txt". Each contact should be on a new line.

#### Exercise 3

Write a program that reads a text file and counts the number of characters, words, and lines in it. Display the results.

#### Exercise 4

Create a program that copies the contents of one text file to another. The source and destination file names should be provided by the user.

#### Exercise 5

Write a program that reads a text file and converts all lowercase letters to uppercase, then writes the result to a new file. The original file should remain unchanged.

### 1.2 File Modes and Error Handling

Understanding file modes and properly handling errors are crucial aspects of working with files in C. In this subchapter, we'll explore the various file modes available in C and learn how to implement robust error handling mechanisms to ensure that your file operations work reliably.

File modes determine how a file is opened and what operations can be performed on it. The mode is specified as a string parameter when calling the `fopen()` function. C provides several modes, including read mode, write mode, append mode, and combinations of these. Each mode has specific behaviors and restrictions that affect how you can interact with the file.

When a file operation fails, C provides mechanisms to detect and handle these failures. Error handling is essential in file operations because external factors, like file permissions or disk space, can cause operations to fail even if your code is correct. By implementing proper error handling, you can make your programs more robust and provide meaningful feedback to users when problems occur.

The `fopen()` function returns a NULL pointer if it fails to open a file. This provides a simple way to check if a file operation was successful. Additionally, C provides the `ferror()` and `feof()` functions to distinguish between different types of errors and end-of-file conditions, allowing for more nuanced error handling.

C also provides the `perror()` function, which prints a descriptive error message based on the value of the global `errno` variable. This can be invaluable for debugging and informing users about what went wrong with a file operation. We'll explore how to use these tools to implement comprehensive error handling in your file operations.

In addition to basic error detection, we'll also cover techniques for error recovery and resource cleanup. This includes ensuring that files are properly closed even when errors occur, which is important for preventing resource leaks and data corruption.

#### Example 1: Different file open modes

```c
#include <stdio.h>

int main() {
    FILE *file1, *file2, *file3, *file4;

    // "r" - Open for reading
    file1 = fopen("existing.txt", "r");
    if (file1 == NULL) {
        printf("Could not open existing.txt for reading\n");
    } else {
        printf("Successfully opened existing.txt for reading\n");
        fclose(file1);
    }

    // "w" - Open for writing (creates new file or truncates existing)
    file2 = fopen("newfile.txt", "w");
    if (file2 == NULL) {
        printf("Could not open newfile.txt for writing\n");
    } else {
        printf("Successfully opened newfile.txt for writing\n");
        fclose(file2);
    }

    // "a" - Open for appending
    file3 = fopen("appendfile.txt", "a");
    if (file3 == NULL) {
        printf("Could not open appendfile.txt for appending\n");
    } else {
        printf("Successfully opened appendfile.txt for appending\n");
        fclose(file3);
    }

    // "r+" - Open for reading and writing
    file4 = fopen("readwrite.txt", "r+");
    if (file4 == NULL) {
        printf("Could not open readwrite.txt for reading and writing\n");
    } else {
        printf("Successfully opened readwrite.txt for reading and writing\n");
        fclose(file4);
    }

    return 0;
}
```

#### Example 2: Using perror() for error messages

```c
#include <stdio.h>
#include <errno.h>

int main() {
    FILE *filePointer;

    // Try to open a file that doesn't exist
    filePointer = fopen("nonexistent.txt", "r");

    if (filePointer == NULL) {
        perror("Error opening file");
        return 1;
    }

    // This code won't execute if the file doesn't exist
    fclose(filePointer);

    return 0;
}
```

#### Example 3: Checking for end-of-file and errors

```c
#include <stdio.h>

int main() {
    FILE *filePointer;
    int ch;

    filePointer = fopen("sample.txt", "r");

    if (filePointer == NULL) {
        perror("Error opening file");
        return 1;
    }

    // Read until end of file or error
    while (1) {
        ch = fgetc(filePointer);

        // Check for end of file
        if (feof(filePointer)) {
            printf("\nEnd of file reached.\n");
            break;
        }

        // Check for error
        if (ferror(filePointer)) {
            printf("\nError reading from file.\n");
            break;
        }

        putchar(ch);
    }

    // Clear any errors
    clearerr(filePointer);

    fclose(filePointer);
    return 0;
}
```

#### Example 4: Advanced error handling with errno

```c
#include <stdio.h>
#include <errno.h>
#include <string.h>

int main() {
    FILE *filePointer;

    errno = 0;  // Reset errno
    filePointer = fopen("protected.txt", "w");

    if (filePointer == NULL) {
        // Get the error number
        int errnum = errno;

        // Print custom error message with error description
        fprintf(stderr, "Error opening file: %s\n", strerror(errnum));

        // Different actions based on error type
        if (errnum == EACCES) {
            printf("Permission denied. Check file permissions.\n");
        } else if (errnum == ENOENT) {
            printf("File not found. Check file path.\n");
        } else {
            printf("Unexpected error occurred.\n");
        }

        return 1;
    }

    // File opened successfully
    fprintf(filePointer, "Testing file write.\n");
    fclose(filePointer);

    return 0;
}
```

#### Example 5: Safe file handling with cleanup

```c
#include <stdio.h>
#include <stdlib.h>

void processFile(const char *filename) {
    FILE *filePointer = NULL;
    char buffer[100];

    // Try to open file
    filePointer = fopen(filename, "r");

    if (filePointer == NULL) {
        perror("Error opening file");
        return;  // Early return on error
    }

    // Use a flag to track successful processing
    int success = 0;

    // Try to read from file
    if (fgets(buffer, sizeof(buffer), filePointer) != NULL) {
        printf("First line: %s", buffer);
        success = 1;
    } else {
        if (feof(filePointer)) {
            printf("File is empty.\n");
        } else {
            perror("Error reading file");
        }
    }

    // Always close the file, regardless of success
    fclose(filePointer);

    // Additional processing based on success
    if (success) {
        printf("File processed successfully.\n");
    }
}

int main() {
    processFile("example.txt");
    processFile("nonexistent.txt");

    return 0;
}
```

#### Exercise 1

Write a program that tries to open a file in read mode. If the file doesn't exist, create it and write some text to it, then close and reopen it for reading.

#### Exercise 2

Create a program that reads integers from a file and calculates their sum. Implement proper error handling for file operations and invalid data in the file.

#### Exercise 3

Write a program that opens multiple files simultaneously and copies content from one to another. Implement robust error handling for each file operation.

#### Exercise 4

Create a program that attempts to write to a read-only file. Handle the specific permission error and display an appropriate message to the user.

#### Exercise 5

Write a function that safely reads a specific line number from a text file. The function should handle all possible errors, including file not found, empty file, and requested line not available.

### 1.3 Text File Processing

Text file processing is a fundamental skill for any C programmer, enabling you to read, write, and manipulate human-readable data stored in files. In this subchapter, we'll explore techniques for working with text files in C, focusing on common operations like reading and writing lines, parsing data, and processing large text files efficiently.

Text files store data as sequences of characters, making them ideal for storing human-readable information like configuration settings, logs, data exports, and more. Unlike binary files, text files can be opened and read using standard text editors, making them accessible and easy to debug. C provides a rich set of functions specifically designed for text file processing, allowing for flexible and powerful manipulation of textual data.

One of the key challenges in text file processing is parsingâ€”extracting meaningful information from the text. We'll explore different techniques for parsing text files, including line-by-line reading, tokenization, and using formatted input functions like `fscanf()`. These techniques allow you to convert text data into the appropriate data types for processing in your program.

Efficiency becomes critical when working with large text files. We'll cover strategies for processing text files efficiently, including buffered I/O and selective reading. These techniques can significantly improve the performance of your applications when dealing with large datasets.

Another important aspect of text file processing is data validation and error handling. We'll discuss how to validate input data from text files and handle cases where the file format doesn't match your expectations. Robust validation ensures that your program can handle real-world data reliably.

#### Example 1: Reading a text file line by line

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    FILE *file;
    char *line = NULL;
    size_t len = 0;
    ssize_t read;

    file = fopen("sample.txt", "r");
    if (file == NULL) {
        perror("Error opening file");
        return EXIT_FAILURE;
    }

    // Read file line by line
    int lineCount = 0;
    while ((read = getline(&line, &len, file)) != -1) {
        lineCount++;
        printf("Line %d (%zu characters): %s", lineCount, read, line);
    }

    // Free the allocated line buffer
    free(line);

    /////////////////
    fclose(file);

    printf("Total lines: %d\n", lineCount);

    return EXIT_SUCCESS;
}
```

#### Example 2: Parsing CSV data from a text file

```c
#include <stdio.h>
#include <string.h>

int main() {
    FILE *file;
    char line[256];
    char *token;

    file = fopen("data.csv", "r");
    if (file == NULL) {
        perror("Error opening file");
        return 1;
    }

    // Read the header line
    if (fgets(line, sizeof(line), file)) {
        printf("CSV Headers: %s", line);
    }

    // Process data lines
    while (fgets(line, sizeof(line), file)) {
        // Remove newline character
        line[strcspn(line, "\n")] = 0;

        printf("Processing: %s\n", line);

        // Parse the CSV line using strtok
        token = strtok(line, ",");
        int column = 1;

        while (token != NULL) {
            printf("Column %d: %s\n", column, token);
            token = strtok(NULL, ",");
            column++;
        }

        printf("\n");
    }

    fclose(file);
    return 0;
}
```

#### Example 3: Writing formatted data to a text file

```c
#include <stdio.h>
#include <time.h>

typedef struct {
    int id;
    char name[50];
    float score;
} Student;

int main() {
    FILE *file;
    Student students[] = {
        {1, "Alice", 92.5},
        {2, "Bob", 85.0},
        {3, "Charlie", 78.5},
        {4, "David", 90.0},
        {5, "Eve", 88.5}
    };
    int numStudents = sizeof(students) / sizeof(students[0]);

    // Get current time for the report header
    time_t now = time(NULL);
    char timeString[64];
    strftime(timeString, sizeof(timeString), "%Y-%m-%d %H:%M:%S", localtime(&now));

    file = fopen("student_report.txt", "w");
    if (file == NULL) {
        perror("Error opening file");
        return 1;
    }

    // Write header with timestamp
    fprintf(file, "STUDENT PERFORMANCE REPORT\n");
    fprintf(file, "Generated on: %s\n\n", timeString);
    fprintf(file, "%-5s %-20s %-10s %s\n", "ID", "Name", "Score", "Grade");
    fprintf(file, "---------------------------------------------\n");

    // Write student data
    float totalScore = 0;
    for (int i = 0; i < numStudents; i++) {
        char grade;

        // Determine grade based on score
        if (students[i].score >= 90) grade = 'A';
        else if (students[i].score >= 80) grade = 'B';
        else if (students[i].score >= 70) grade = 'C';
        else if (students[i].score >= 60) grade = 'D';
        else grade = 'F';

        fprintf(file, "%-5d %-20s %-10.2f %c\n",
                students[i].id, students[i].name, students[i].score, grade);

        totalScore += students[i].score;
    }

    // Write summary
    fprintf(file, "---------------------------------------------\n");
    fprintf(file, "Average Score: %.2f\n", totalScore / numStudents);

    fclose(file);
    printf("Student report has been written to student_report.txt\n");

    return 0;
}
```

#### Example 4: Finding and replacing text in a file

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    FILE *sourceFile, *tempFile;
    char line[1024];
    char searchString[100], replaceString[100];
    int count = 0;

    // Get search and replace strings from user
    printf("Enter the search string: ");
    fgets(searchString, sizeof(searchString), stdin);
    searchString[strcspn(searchString, "\n")] = 0; // Remove newline

    printf("Enter the replace string: ");
    fgets(replaceString, sizeof(replaceString), stdin);
    replaceString[strcspn(replaceString, "\n")] = 0; // Remove newline

    // Open source file for reading
    sourceFile = fopen("source.txt", "r");
    if (sourceFile == NULL) {
        perror("Error opening source file");
        return 1;
    }

    // Open temp file for writing
    tempFile = fopen("temp.txt", "w");
    if (tempFile == NULL) {
        perror("Error creating temp file");
        fclose(sourceFile);
        return 1;
    }

    // Process the file line by line
    while (fgets(line, sizeof(line), sourceFile)) {
        char *position = strstr(line, searchString);

        // If search string is found in this line
        if (position) {
            char newLine[1024];
            char *cursor = line;
            newLine[0] = '\0';

            // Process all occurrences in the current line
            while (position) {
                int offset = position - cursor;

                // Copy from cursor to position
                strncat(newLine, cursor, offset);

                // Copy the replacement string
                strcat(newLine, replaceString);

                // Move cursor past the search string
                cursor = position + strlen(searchString);

                // Look for next occurrence
                position = strstr(cursor, searchString);

                count++;
            }

            // Copy the rest of the line
            strcat(newLine, cursor);

            // Write the modified line
            fputs(newLine, tempFile);
        } else {
            // No match in this line, write the original
            fputs(line, tempFile);
        }
    }

    // Close both files
    fclose(sourceFile);
    fclose(tempFile);

    // Replace the original file with the modified file
    remove("source.txt");
    rename("temp.txt", "source.txt");

    printf("Replaced %d occurrence(s) of '%s' with '%s'\n",
           count, searchString, replaceString);

    return 0;
}
```

#### Example 5: Merging multiple text files

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int mergeFile(FILE *target, const char *sourceFileName) {
    FILE *source;
    char buffer[1024];

    source = fopen(sourceFileName, "r");
    if (source == NULL) {
        fprintf(stderr, "Error opening %s: ", sourceFileName);
        perror("");
        return 0;
    }

    // Write file name as header
    fprintf(target, "\n\n===== Contents of %s =====\n\n", sourceFileName);

    // Copy contents
    while (fgets(buffer, sizeof(buffer), source)) {
        fputs(buffer, target);
    }

    fclose(source);
    return 1;
}

int main(int argc, char *argv[]) {
    FILE *targetFile;
    int filesProcessed = 0;

    if (argc < 3) {
        printf("Usage: %s targetfile sourcefile1 [sourcefile2 ...]\n", argv[0]);
        return 1;
    }

    // Open target file
    targetFile = fopen(argv[1], "w");
    if (targetFile == NULL) {
        perror("Error creating target file");
        return 1;
    }

    // Write header
    fprintf(targetFile, "MERGED FILE CREATED: %s\n", __DATE__);
    fprintf(targetFile, "Contains content from the following files:\n");

    for (int i = 2; i < argc; i++) {
        fprintf(targetFile, "- %s\n", argv[i]);
    }

    // Process each source file
    for (int i = 2; i < argc; i++) {
        if (mergeFile(targetFile, argv[i])) {
            filesProcessed++;
        }
    }

    fclose(targetFile);

    printf("Merge complete. Processed %d out of %d files.\n",
           filesProcessed, argc - 2);

    return 0;
}
```

#### Exercise 1

Write a program that reads a text file and counts the frequency of each word, then displays the 10 most common words and their counts.

#### Exercise 2

Create a program that reads a configuration file with key-value pairs (e.g., "server=localhost") and stores the values in a structure. Implement proper error handling for missing or malformed entries.

#### Exercise 3

Write a program that reads a CSV file containing student information (name, ID, scores in multiple subjects) and calculates each student's average score and grade.

#### Exercise 4

Create a log file analyzer that reads a log file, extracts timestamp, log level, and message, and generates a summary report with counts of each log level.

#### Exercise 5

Write a program that reads a text file containing dates in various formats (DD/MM/YYYY, MM-DD-YYYY, etc.) and converts them all to a standardized format (YYYY-MM-DD) in a new file.

### 1.4 Advanced Text File Techniques

Advanced text file processing techniques enable you to handle more complex scenarios when working with files. In this subchapter, we'll explore sophisticated methods for manipulating text files in C, including working with temporary files, random access in text files, memory-mapped files, and handling large datasets efficiently.

Working with temporary files is essential for many file processing tasks, such as when you need to create intermediate results without cluttering the filesystem. C provides functions like `tmpfile()` and `tmpnam()` specifically for creating and managing temporary files, which are automatically deleted when no longer needed.

While text files are typically processed sequentially, random access techniques allow you to jump to specific positions within a file. This can be particularly useful when working with structured text formats or when you need to update specific portions of a file without reading or rewriting the entire content.

Memory-mapped files provide a powerful way to access file contents directly in memory, potentially improving performance for certain operations. By mapping a file into memory, you can access its contents as if they were stored in an array, which can simplify code and improve efficiency for random access patterns.

Processing large text files efficiently requires special techniques to avoid excessive memory usage. We'll explore approaches such as chunked processing and stream processing, which allow you to handle files much larger than available memory while maintaining good performance.

#### Example 1: Working with temporary files

```c
#include <stdio.h>
#include <string.h>

int main() {
    FILE *tempFile;
    char buffer[100];

    // Create a temporary file
    tempFile = tmpfile();
    if (tempFile == NULL) {
        perror("Failed to create temporary file");
        return 1;
    }

    // Write data to temporary file
    fprintf(tempFile, "This is line 1 of temporary data.\n");
    fprintf(tempFile, "This is line 2 of temporary data.\n");
    fprintf(tempFile, "This is line 3 of temporary data.\n");

    // Reset file position indicator to beginning
    rewind(tempFile);

    // Read and display the temporary file contents
    printf("Temporary file contents:\n");
    while (fgets(buffer, sizeof(buffer), tempFile)) {
        printf("%s", buffer);
    }

    // Close the temporary file (automatically deletes it)
    fclose(tempFile);

    printf("\nTemporary file has been closed and deleted.\n");

    return 0;
}
```

#### Example 2: Random access in text files

```c
#include <stdio.h>
#include <string.h>

#define MAX_LINE_LENGTH 256

// Function to get the file position of a specific line
long getLinePosition(FILE *file, int targetLine) {
    char buffer[MAX_LINE_LENGTH];
    int currentLine = 0;
    long position = 0;

    // Reset to beginning of file
    rewind(file);

    // Find the position of the target line
    while (currentLine < targetLine && fgets(buffer, sizeof(buffer), file)) {
        position = ftell(file);
        currentLine++;
    }

    return position;
}

int main() {
    FILE *file;
    char buffer[MAX_LINE_LENGTH];
    long position;
    int lineNum;

    // Create a test file
    file = fopen("random_access.txt", "w+");
    if (file == NULL) {
        perror("Error creating file");
        return 1;
    }

    // Write numbered lines to the file
    for (int i = 1; i <= 10; i++) {
        fprintf(file, "This is line %d of the test file.\n", i);
    }

    // Ask user which line to read
    printf("Enter a line number (1-10) to read: ");
    scanf("%d", &lineNum);

    if (lineNum < 1 || lineNum > 10) {
        printf("Invalid line number!\n");
        fclose(file);
        return 1;
    }

    // Get position of the requested line
    position = getLinePosition(file, lineNum - 1);

    // Seek to that position
    fseek(file, position, SEEK_SET);

    // Read and display the line
    if (fgets(buffer, sizeof(buffer), file)) {
        printf("Line %d: %s", lineNum, buffer);
    } else {
        printf("Failed to read line %d\n", lineNum);
    }

    // Modify a specific line
    printf("\nNow modifying line %d\n", lineNum);

    // Return to position of that line
    fseek(file, position, SEEK_SET);

    // Write new content (must be same length to avoid shifting other lines)
    char newLine[MAX_LINE_LENGTH];
    sprintf(newLine, "This is MODIFIED line %d of the test file.\n", lineNum);

    // Ensure new line is same length as original
    fputs(newLine, file);

    // Display entire file after modification
    printf("\nFile contents after modification:\n");
    rewind(file);

    int currentLine = 1;
    while (fgets(buffer, sizeof(buffer), file)) {
        printf("%d: %s", currentLine, buffer);
        currentLine++;
    }

    fclose(file);
    return 0;
}
```

#### Example 3: Processing a file in chunks

```c
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>

#define CHUNK_SIZE 1024

// Process a chunk of text (convert to uppercase)
void processChunk(char *chunk, size_t size) {
    for (size_t i = 0; i < size; i++) {
        chunk[i] = toupper(chunk[i]);
    }
}

int main() {
    FILE *inputFile, *outputFile;
    char buffer[CHUNK_SIZE];
    size_t bytesRead;
    long totalBytes = 0;

    // Open input and output files
    inputFile = fopen("input.txt", "r");
    if (inputFile == NULL) {
        perror("Error opening input file");
        return 1;
    }

    outputFile = fopen("output.txt", "w");
    if (outputFile == NULL) {
perror("Error opening output file");
        fclose(inputFile);
        return 1;
    }

    // Process file in chunks
    while ((bytesRead = fread(buffer, 1, CHUNK_SIZE, inputFile)) > 0) {
        // Process this chunk
        processChunk(buffer, bytesRead);

        // Write processed chunk to output
        fwrite(buffer, 1, bytesRead, outputFile);

        // Update statistics
        totalBytes += bytesRead;
    }

    // Check for read error
    if (ferror(inputFile)) {
        perror("Error reading from file");
    }

    // Close files
    fclose(inputFile);
    fclose(outputFile);

    printf("Processing complete. %ld bytes processed.\n", totalBytes);

    return 0;
}
```

#### Example 4: Line-oriented streaming with limited memory

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

// Process a single line of text
void processLine(char *line, FILE *output) {
    int i, j;
    int length = strlen(line);

    // Simple word capitalization: capitalize first letter of each word
    int capitalize_next = 1;

    for (i = 0; i < length; i++) {
        if (isspace(line[i])) {
            capitalize_next = 1;
        } else if (capitalize_next) {
            line[i] = toupper(line[i]);
            capitalize_next = 0;
        }
    }

    // Write processed line to output
    fputs(line, output);
}

int main() {
    FILE *input, *output;
    char *line = NULL;
    size_t len = 0;
    ssize_t read;
    long lineCount = 0;

    // Open files
    input = fopen("large_text.txt", "r");
    if (input == NULL) {
        perror("Error opening input file");
        return 1;
    }

    output = fopen("capitalized_text.txt", "w");
    if (output == NULL) {
        perror("Error opening output file");
        fclose(input);
        return 1;
    }

    // Process one line at a time
    while ((read = getline(&line, &len, input)) != -1) {
        processLine(line, output);
        lineCount++;

        // Give progress update every 10000 lines
        if (lineCount % 10000 == 0) {
            printf("Processed %ld lines...\n", lineCount);
        }
    }

    // Free allocated memory
    free(line);

    // Close files
    fclose(input);
    fclose(output);

    printf("Processing complete. Total lines processed: %ld\n", lineCount);

    return 0;
}
```

#### Example 5: Finding content across multiple files

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dirent.h>

#define MAX_PATH 260
#define MAX_LINE 1024

// Search for a string in a file
void searchInFile(const char *filename, const char *searchStr) {
    FILE *file;
    char line[MAX_LINE];
    int lineNum = 0;
    int found = 0;

    file = fopen(filename, "r");
    if (file == NULL) {
        fprintf(stderr, "Could not open %s: ", filename);
        perror("");
        return;
    }

    while (fgets(line, sizeof(line), file)) {
        lineNum++;

        if (strstr(line, searchStr)) {
            if (!found) {
                // Print filename header for first match
                printf("\nMatches in %s:\n", filename);
                found = 1;
            }

            // Remove newline character for display
            line[strcspn(line, "\n")] = 0;

            // Print match with line number
            printf("  Line %d: %s\n", lineNum, line);
        }
    }

    fclose(file);
}

int main(int argc, char *argv[]) {
    DIR *dir;
    struct dirent *entry;
    char path[MAX_PATH];
    int filesSearched = 0;

    if (argc != 3) {
        printf("Usage: %s <directory> <search_string>\n", argv[0]);
        return 1;
    }

    // Open directory
    dir = opendir(argv[1]);
    if (dir == NULL) {
        perror("Could not open directory");
        return 1;
    }

    printf("Searching for '%s' in '%s'...\n", argv[2], argv[1]);

    // Iterate over files in directory
    while ((entry = readdir(dir)) != NULL) {
        // Skip directory entries
        if (entry->d_type == DT_DIR) continue;

        // Only process text files (simple check for .txt extension)
        const char *ext = strrchr(entry->d_name, '.');
        if (!ext || strcmp(ext, ".txt") != 0) continue;

        // Create full path
        snprintf(path, MAX_PATH, "%s/%s", argv[1], entry->d_name);

        // Search in this file
        searchInFile(path, argv[2]);
        filesSearched++;
    }

    closedir(dir);

    printf("\nSearch complete. Searched %d text files.\n", filesSearched);

    return 0;
}
```

#### Exercise 1

Write a program that processes a large CSV file in chunks, calculating statistics (sum, average, min, max) for each numeric column without loading the entire file into memory.

#### Exercise 2

Create a program that can search for a specific pattern (using simple string matching or regular expressions) across multiple text files, displaying matching lines with file name and line number.

#### Exercise 3

Write a program that reads a large text file and creates an index of words, storing the file position of each occurrence so they can be quickly accessed later. Save this index to a separate file.

#### Exercise 4

Create a program that splits a large text file into multiple smaller files based on a maximum line count per file, while ensuring that no line is cut in the middle.

#### Exercise 5

Write a program that merges multiple sorted text files (containing one number per line) into a single sorted file, using a memory-efficient algorithm that doesn't require loading all numbers into memory at once.

## Chapter 2: File System Operations

### 2.1 Directory Operations

Directory operations are essential for building applications that need to interact with the file system beyond individual files. In this subchapter, we'll explore how C programs can work with directories, including listing directory contents, creating and removing directories, and traversing directory structures.

Working with directories allows your programs to interact with the file system at a higher level than individual file operations. Directory operations enable you to scan folders for files matching certain criteria, organize files into meaningful structures, and manage file collections efficiently. These capabilities are crucial for applications like file managers, backup utilities, and data processing tools.

The C standard library doesn't provide direct functions for directory operations, but most systems offer a set of functions through the `<dirent.h>` header, which is part of the POSIX standard. These functions allow you to open, read, and close directories, similar to how you would work with files. While not part of standard C, these functions are widely supported on Unix-like systems, including Linux and macOS.

On Windows systems, you can use different functions from the Windows API for directory operations, though we'll focus primarily on the POSIX approach in this subchapter. Keep in mind that if you need to write cross-platform code, you may need to use conditional compilation to handle the differences between platforms.

Beyond basic directory access, we'll also explore techniques for recursive directory traversal, which allow your programs to process entire directory trees. This capability is useful for operations like searching for files throughout a directory structure, calculating disk usage, or backing up an entire directory hierarchy.

#### Example 1: Listing files in a directory

```c
#include <stdio.h>
#include <dirent.h>
#include <stdlib.h>

int main() {
    DIR *dir;
    struct dirent *entry;
    int count = 0;

    // Open current directory
    dir = opendir(".");

    if (dir == NULL) {
        perror("Unable to open directory");
        return EXIT_FAILURE;
    }

    printf("Contents of current directory:\n");

    // Read directory entries
    while ((entry = readdir(dir)) != NULL) {
        printf("%s\n", entry->d_name);
        count++;
    }

    // Close directory
    closedir(dir);

    printf("\nTotal %d entries found.\n", count);

    return EXIT_SUCCESS;
}
```

#### Example 2: Filtering directory contents by file type

```c
#include <stdio.h>
#include <dirent.h>
#include <string.h>
#include <sys/stat.h>

// Function to get file extension
const char *getFileExtension(const char *filename) {
    const char *dot = strrchr(filename, '.');
    if (!dot || dot == filename) return "";
    return dot + 1;
}

int main(int argc, char *argv[]) {
    DIR *dir;
    struct dirent *entry;
    char path[1024];
    struct stat file_stat;

    // Check if directory path was provided
    const char *dirPath = argc > 1 ? argv[1] : ".";

    dir = opendir(dirPath);
    if (dir == NULL) {
        perror("Unable to open directory");
        return 1;
    }

    printf("Files by type in directory: %s\n\n", dirPath);

    // Initialize counters
    int dirs = 0, regFiles = 0, txtFiles = 0, cFiles = 0, otherFiles = 0;

    // Read directory entries
    while ((entry = readdir(dir)) != NULL) {
        // Create full path
        snprintf(path, sizeof(path), "%s/%s", dirPath, entry->d_name);

        // Get file statistics
        if (stat(path, &file_stat) < 0) {
            perror("stat");
            continue;
        }

        // Check file type
        if (S_ISDIR(file_stat.st_mode)) {
            printf("[DIR]  %s\n", entry->d_name);
            dirs++;
        } else if (S_ISREG(file_stat.st_mode)) {
            const char *ext = getFileExtension(entry->d_name);

            if (strcmp(ext, "txt") == 0) {
                printf("[TXT]  %s\n", entry->d_name);
                txtFiles++;
            } else if (strcmp(ext, "c") == 0) {
                printf("[C]    %s\n", entry->d_name);
                cFiles++;
            } else {
                printf("[FILE] %s\n", entry->d_name);
                otherFiles++;
            }

            regFiles++; // Count all regular files
        }
    }

    closedir(dir);

    // Print summary
    printf("\nSummary:\n");
    printf("  Directories: %d\n", dirs);
    printf("  Regular files: %d\n", regFiles);
    printf("    Text files (.txt): %d\n", txtFiles);
    printf("    C source files (.c): %d\n", cFiles);
    printf("    Other files: %d\n", otherFiles);

    return 0;
}
```

#### Example 3: Creating and removing directories

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <errno.h>
#include <unistd.h>

// Function to check if directory exists
int directoryExists(const char *path) {
    struct stat stats;
    return stat(path, &stats) == 0 && S_ISDIR(stats.st_mode);
}

// Function to create a directory
int createDirectory(const char *path) {
    // Create directory with read/write/execute permissions for owner
    // and read/execute permissions for group and others
    int status = mkdir(path, 0755);

    if (status == 0) {
        printf("Directory '%s' created successfully.\n", path);
        return 1;
    } else {
        if (errno == EEXIST) {
            printf("Directory '%s' already exists.\n", path);
            return 1;
        } else {
            perror("Error creating directory");
            return 0;
        }
    }
}

// Function to remove a directory
int removeDirectory(const char *path) {
    int status = rmdir(path);

    if (status == 0) {
        printf("Directory '%s' removed successfully.\n", path);
        return 1;
    } else {
        perror("Error removing directory");
        return 0;
    }
}

int main() {
    char dirName[100];
    int choice;

    while (1) {
        printf("\nDirectory Operations:\n");
        printf("1. Create a directory\n");
        printf("2. Remove a directory\n");
        printf("3. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);
        getchar(); // Consume newline

        switch (choice) {
            case 1:
                printf("Enter directory name to create: ");
                fgets(dirName, sizeof(dirName), stdin);
                dirName[strcspn(dirName, "\n")] = 0; // Remove newline

                createDirectory(dirName);
                break;

            case 2:
                printf("Enter directory name to remove: ");
                fgets(dirName, sizeof(dirName), stdin);
                dirName[strcspn(dirName, "\n")] = 0; // Remove newline

                if (!directoryExists(dirName)) {
                    printf("Directory '%s' does not exist.\n", dirName);
                } else {
                    removeDirectory(dirName);
                }
                break;

            case 3:
                printf("Exiting program.\n");
                return 0;

            default:
                printf("Invalid choice. Please try again.\n");
        }
    }

    return 0;
}
```

#### Example 4: Recursive directory traversal

```c
#include <stdio.h>
#include <dirent.h>
#include <string.h>
#include <sys/stat.h>
#include <stdlib.h>

#define MAX_PATH 1024

// Function to process a file
void processFile(const char *filepath) {
    printf("File: %s\n", filepath);
    // Add your file processing logic here
}

// Recursive directory traversal function
void traverseDirectory(const char *basePath, int level) {
    char path[MAX_PATH];
    struct dirent *entry;
    DIR *dir = opendir(basePath);
    struct stat statbuf;

    if (!dir) {
        perror("Unable to open directory");
        return;
    }

    // Print indentation based on level
    for (int i = 0; i < level; i++) {
        printf("  ");
    }
    printf("[DIR] %s\n", basePath);

    while ((entry = readdir(dir)) != NULL) {
        // Skip "." and ".." directories
        if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0) {
            continue;
        }

        // Create full path
        snprintf(path, sizeof(path), "%s/%s", basePath, entry->d_name);

        // Get file/directory statistics
```
